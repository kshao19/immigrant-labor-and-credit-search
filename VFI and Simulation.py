# -*- coding: utf-8 -*-
"""Functions_Kailai.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TlE6SX14syHSlscFSI7gkwd63r0cFzOm

# **Herkenhoff 2019**

# Libraries
"""

import time
import numpy as np
from scipy.stats import norm

from numpy import savetxt
import pandas as pd
import math
import random

import scipy.io as sio

#define the following class for the exogenous variables in Herkenhoff 2019
#@jitclass(data_type)
class herkenhoff19:
    def __init__(self, gamma, delt, zeta, rf, zeta_c, tau, s_bar, Kc, sig, T, x, px, KL, bet, KD, eps_D, chi_c, eps, eta, A, Y, Pi, w_grid, z_grid, b_grid, r_grid, b_step, Nw, Nz, Ninc, Nb, Nr, Ny, T_econ, N):
      self.gamma, self.delt, self.zeta, self.rf, self.zeta_c = gamma, delt, zeta, rf, zeta_c
      self.tau, self.s_bar, self.Kc, self.sig, self.T = tau, s_bar, Kc, sig, T
      self.x, self.px, self.KL, self.bet, self.KD, self.eps_D = x, px, KL, bet, KD, eps_D
      self.chi_c, self.eps, self.eta, self.A = chi_c, eps, eta, A
      self.Y, self.Pi = Y, Pi
      self.w_grid, self.z_grid, self.b_grid, self.r_grid, self.b_step = w_grid, z_grid, b_grid, r_grid, b_step
      self.Nw, self.Nz, self.Ninc, self.Nb, self.Nr, self.Ny = Nw, Nz, Ninc, Nb, Nr, Ny
      self.T_econ, self.N  = T_econ, N

"""# Firm's Problem"""

## find pt: job finding probability

##############################################################################
##############################################################################

def J_VFI(herkenhoff19_class):

    """

    Output (3D):
    Jt_mat   firm's profit for every combinations of w & y and for all quarters
    pt       job finding probabilities for every combinations of w & y and for all quarters

    """

    #initialize exogenous variables
    T = herkenhoff19_class.T
    Y = herkenhoff19_class.Y
    w_vec = herkenhoff19_class.w_grid
    Nw, Ny = herkenhoff19_class.Nw, herkenhoff19_class.Ny
    KL, bet, delt, zeta = herkenhoff19_class.KL, herkenhoff19_class.bet, herkenhoff19_class.delt, herkenhoff19_class.zeta
    eps = herkenhoff19_class.eps
    Pi = herkenhoff19_class.Pi

    #Initialize vectors to store updated values and job finding probabilities
    Jt_mat = np.zeros((Ny, Nw, T))
    pt = np.zeros((Ny, Nw, T))
    thet_mat = np.zeros((Ny, Nw, T))

    Jold_mat = np.zeros((Ny, Nw))

    w_grid, y_grid = np.meshgrid(w_vec, Y, indexing='xy')

    #loop over the periods
    for t in range (T-1, -1, -1):
      EJp_mat = (1-delt)*(np.dot(Pi, Jold_mat))

      Jnew_mat = y_grid - w_grid + bet*EJp_mat

      thet_tmp = np.maximum(Jnew_mat, eps)
      thet_tmp_max = (KL / thet_tmp)**(-zeta) - 1
      thet_tmp_max = np.maximum(thet_tmp_max, 0) # so that the vacancy filling rate ft < 1 and to make sure J_mat > 0, thus thet > 0
      thet_max = thet_tmp_max**(1/zeta)

      #compute job finding probability
      p_job = thet_max/((thet_max**zeta+1)**(1/zeta))

      Jt_mat[:,:,t] = Jnew_mat
      pt[:,:,t] = p_job
      thet_mat[:,:,t] = thet_max.copy()

      Jold_mat = Jnew_mat

    return Jt_mat, pt, thet_mat

"""# VFI

# Household Problem at T

**Period T Solution**
"""

def VPT_mat(pt, herkenhoff19_class):
    sig, KD, eta, px, eps_D = herkenhoff19_class.sig, herkenhoff19_class.KD, herkenhoff19_class.eta, herkenhoff19_class.px, herkenhoff19_class.eps_D
    s_bar, bet, delt = herkenhoff19_class.s_bar, herkenhoff19_class.bet, herkenhoff19_class.delt
    w_vec, z_vec, b_vec, r_vec = herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
    b_step = herkenhoff19_class.b_step
    A = herkenhoff19_class.A
    Y = herkenhoff19_class.Y
    Pi = herkenhoff19_class.Pi
    Nw, Nz, Ninc, Nb, Nr, Ny = herkenhoff19_class.Nw, herkenhoff19_class.Nz, herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny
    px = herkenhoff19_class.px
    eps = herkenhoff19_class.eps

    pT_long = pt[:, :, -1][:, :, None, None]
    pT_long = np.repeat(np.repeat(pT_long, Nz, axis=2), Nb, axis=3)

    pT_short = pt[:, :, -1][:, :,  None]
    pT_short = np.repeat(pT_short, Nb, axis=2)

    z = z_vec[None, :, None, None] # (Ny, Ninc, Nb, Nr)
    b = b_vec[None, None, :, None]
    w = w_vec[None, :, None, None]
    y = Y[:, None, None, None]
    r = r_vec[None, None, None, :]

    c_e = np.repeat(w + np.where(b >= 0, 1.0, r) * b, Ny, axis=0)
    c_u = np.repeat(z + np.where(b >= 0, 1.0, r) * b, Ny, axis=0)

    c_cons_e = np.maximum(c_e, eps)
    c_cons_u = np.maximum(c_u, eps)

    uc_e = (c_cons_e ** (1 - sig) - 1) / (1 - sig)
    uc_u = (c_cons_u ** (1 - sig) - 1) / (1 - sig)
    xd = KD * ((1 - r) / (r + eps_D))

    V_new_e = uc_e - xd - 1e10 * (c_e <= 0)
    V_new_u = uc_u - xd + eta - 1e10 * (c_u <= 0)

    V_e_max = np.max(V_new_e, axis=-1)
    V_e_max_long = np.repeat(V_e_max[:, :, None, :], Nz, axis=2)
    V_u_max = np.max(V_new_u, axis=-1)
    V_u_max_long = np.repeat(V_u_max[:, None, :, :], Nw, axis=1)

    irc_max_e = np.argmax(V_new_e, axis=-1)
    irc_max_u = np.argmax(V_new_u, axis=-1)
    irn_max_u = irc_max_u
    irn_max_e = irc_max_e

    VC_e_max = V_e_max
    VC_u_max = V_u_max
    VN_e_max = V_e_max
    VN_u_max = V_u_max

    ib = np.arange(Nb)
    ib_es = np.where(ib <= b_step, 0, ib - b_step)
    ib_es_long = ib_es[None, None, None, :]
    ib_es_short = ib_es[None, None, :]

    V_e_es_max_long = np.take_along_axis(V_e_max_long, ib_es_long.repeat(Ny, axis=0).repeat(Nw, axis=1).repeat(Nz, axis=2), axis=3)
    V_e_es_max = np.take_along_axis(V_e_max, ib_es_short.repeat(Ny, axis=0).repeat(Nw, axis=1), axis=2)
    irc_e_es_max = np.take_along_axis(irc_max_e, ib_es_short.repeat(Ny, axis=0).repeat(Nw, axis=1), axis=2)
    irn_e_es_max = irc_e_es_max
    V_u_es_max_long = np.take_along_axis(V_u_max_long, ib_es_long.repeat(Ny, axis=0).repeat(Nw, axis=1).repeat(Nz, axis=2), axis=3)
    V_u_es_max = np.take_along_axis(V_u_max, ib_es_short.repeat(Ny, axis=0).repeat(Nw, axis=1), axis=2)
    irc_u_es_max = np.take_along_axis(irc_max_u, ib_es_short.repeat(Ny, axis=0).repeat(Nw, axis=1), axis=2)
    irn_u_es_max = irc_u_es_max

    V_e_hat_long = px * V_e_es_max_long + (1 - px) * V_e_max_long
    V_e_hat = px * V_e_es_max + (1 - px) * V_e_max
    VC_e_hat = V_e_hat
    V_u_hat = px * V_u_es_max + (1 - px) * V_u_max
    V_u_hat_long = px * V_u_es_max_long + (1 - px) * V_u_max_long
    VC_u_hat = V_u_hat

    UP = pT_long * V_e_hat_long + (1 - pT_long) * V_u_hat_long
    UPC = UP.copy()

    UP_max = np.max(UP, axis=1)
    UPC_max = np.max(UPC, axis=1)
    iw_max = np.argmax(UP, axis=1)
    iwc_max = np.argmax(UPC, axis=1)

    iy = np.arange(Ny)[:, None, None]      # shape: (Ny, 1, 1)
    ib = np.arange(Nb)[None, None, :]      # shape: (1, 1, Nb)

    # Broadcast iy and ib to match iw_max_exp shape
    # Index into irc_max_e with iy, iw_max_exp, and ib
    jf_UP_max = pT_short[iy, iw_max, ib]
    jf_UPC_max = jf_UP_max

    r_WN, r_WN_es, r_WC, r_WC_es = r_vec[irn_max_e], r_vec[irn_e_es_max],\
            r_vec[irc_max_e], r_vec[irc_e_es_max]
    r_UN, r_UN_es, r_UC, r_UC_es = r_vec[irn_max_u], r_vec[irn_u_es_max], \
            r_vec[irc_max_u], r_vec[irc_u_es_max]

    r_N_UP = r_WN[iy, iw_max, ib]
    r_C_UP = r_WC[iy, iw_max, ib]
    r_C_UPC = r_WC[iy, iwc_max, ib]
    r_N_UP_es = r_WN[iy, iw_max, ib_es]
    r_C_UP_es = r_WC[iy, iw_max, ib_es]
    r_C_UPC_es = r_WC[iy, iwc_max, ib_es]

    w_UP = w_vec[iw_max]
    w_UPC = w_UP

    return (
        V_e_max, VC_e_max, VN_e_max, V_u_max, VC_u_max, VN_u_max,
        V_e_hat, VC_e_hat,
        irc_max_e, irn_max_e, irc_max_u, irn_max_u,
        r_WN, r_WN_es, r_WC, r_WC_es,
        r_UN, r_UN_es, r_UC, r_UC_es,
        r_N_UP, r_N_UP_es, r_C_UP, r_C_UP_es,
        r_C_UPC, r_C_UPC_es,
        iw_max, iwc_max,
        jf_UP_max, jf_UPC_max, UP_max, UPC_max, w_UP, w_UPC
    )

"""# Household Problem from Period T-1 and backwards

Before returning to solving hh problem in T-1, first define the following **auxiliary functions**:


1.   Expected utility given expense shock
2.   Bond Price
3.   Lender's Profit
4.   Credit Finding Probability
5.   Whether a given household applies for credit
6.   Storing Household Policy Function
"""

############################### 2. Bond Price ##################################

def bond_price_nodef_vec(c_pol_w, c_pol_u, c_pol_u_es,
    c_pol_UP, c_pol_es_UP,
    A_psi_w, A_psi_u, A_psi_w_es, A_psi_u_es,
    A_psi_UP, A_psi_es_UP, A_psi_UPC, A_psi_es_UPC,
    r_WN, r_WN_es, r_WC, r_WC_es,
    r_UN, r_UN_es, r_UC, r_UC_es,
    r_N_UP, r_N_es_UP, r_C_UP, r_C_es_UP,
    r_C_UPC, r_C_UPC_es,
    jf_UP, jf_UPC,
    herkenhoff19_class):

  # retrieve parameters from class object
  sig, KD, eta, px, eps_D = herkenhoff19_class.sig, herkenhoff19_class.KD, herkenhoff19_class.eta, herkenhoff19_class.px, herkenhoff19_class.eps_D
  s_bar, bet, delt, rf, tau = herkenhoff19_class.s_bar, herkenhoff19_class.bet, herkenhoff19_class.delt, herkenhoff19_class.rf, herkenhoff19_class.tau
  Pi = herkenhoff19_class.Pi
  b_vec = herkenhoff19_class.b_grid
  r_vec = herkenhoff19_class.r_grid
  Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
      herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)

  bp_grid = b_vec[None, None, :]  # shape: (1, 1, Nbp)
  bp_grid = np.broadcast_to(bp_grid, (Ny, Nz, Nb))
  disc = np.where(bp_grid < 0, 1 / (1 + rf + tau), 1 / (1 + rf))

  ############################### Employed Bond Price ###############################
  ##############
  ## Case 1: when credit relationship breaks exogenously

  # 1. when job relationship does not break exogenously, the expected repayment for employed people
  #    who keep their current w given whether they apply for credit
  w1_main = (1 - c_pol_w * A_psi_w) * r_WN + (c_pol_w * A_psi_w) * r_WC
  w1_es = (1 - c_pol_w * A_psi_w_es) * r_WN_es + (c_pol_w * A_psi_w_es) * r_WC_es

  r_hat_w1_n_w1 = ((1-delt) * (    (1-px) * ( w1_main )
                        + px * (   w1_es  )    ))

  # 2. when job relationship breaks exogenously, the expected repayment for previously employed people who:
  # a). tried to find a job that pays w_tilde
  # b). but end up not finding a job and receives unemployment benefits, i.e. γ*current wage (iz=iw) given whether they apply for credit access
  u2_main = (1 - c_pol_u * A_psi_u) * r_UN + (c_pol_u * A_psi_u) * r_UC
  u2_es = (1 - c_pol_u * A_psi_u_es) * r_UN_es + (c_pol_u * A_psi_u_es) * r_UC_es
  r_hat_w1_n_u2 = delt * (1 - jf_UP) * ((1 - px) * u2_main + px * u2_es)

  # 3. when job relationship breaks exogenously, the expected repayment for previously employed people who:
  # a). tried to find a job that pays w∗
  # b). and end up finding one that pays w∗ regardless of whether they apply for credit access
  up_main = (1 - c_pol_UP * A_psi_UP) * r_N_UP + (c_pol_UP * A_psi_UP) * r_C_UP
  up_es = (1 - c_pol_UP * A_psi_es_UP) * r_N_es_UP + (c_pol_UP * A_psi_es_UP) * r_C_es_UP
  r_hat_w1_n_w2 = delt * jf_UP * ((1 - px) * up_main + px * up_es)

  ##############
  ## Case 2: when credit relationship does not break exogenously

  # 1. when job relationship does not break exogenously, the expected repayment for employed people who retain credit access and keep their current w
  r_hat_w1_c_w1 = (1 - delt) * ((1 - px) * r_WC + px * r_WC_es)

  # 2. when job relationship breaks exogenously, the expected repayment for previously employed people who retain credit access and :
  # a). tried to find a job that pays w∗
  # b). but end up not finding a job and receives unemployment benefits, i.e. γ*current wage (iz=iw)
  r_hat_w1_c_u2 = delt * (1 - jf_UPC) * ((1 - px) * r_UC + px * r_UC_es)

  # 3. when job relationship breaks exogenously, the expected repayment for previously employed people who retain credit access and :
  # a). tried to find a job that pays w∗
  # b). and end up finding one that pays w∗
  r_hat_w1_c_w2 = delt * jf_UPC * ((1 - px) * r_C_UPC + px * r_C_UPC_es)

  #################################################################################################################################
  ############################### Unemployed Bond Price ###############################
  ##############
  ## Case 1: when credit relationship breaks exogenously

  # 1. the expected repayment for previously unemployed people who:
  # a). tried to find a job that pays w∗
  # b). and end up finding one that pays w∗ given whether they apply for credit access
  up_main = (1 - c_pol_UP * A_psi_UP) * r_N_UP + (c_pol_UP * A_psi_UP) * r_C_UP
  up_es = (1 - c_pol_es_UP * A_psi_es_UP) * r_N_es_UP + (c_pol_es_UP * A_psi_es_UP) * r_C_es_UP
  r_hat_u1_n_w2 = jf_UP * ((1 - px) * up_main + px * up_es)

  # 2. the expected repayment for previously unemployed people who:
  # a). tried to find a job that pays w∗
  # b). but end up not finding a job and continue to receive unemployment benefits, i.e. γw given whether they apply for credit access
  u1_main = (1 - c_pol_u * A_psi_u) * r_UN + (c_pol_u * A_psi_u) * r_UC
  u1_es = (1 - c_pol_u_es * A_psi_u_es) * r_UN_es + (c_pol_u_es * A_psi_u_es) * r_UC_es
  r_hat_u1_n_u1 = (1 - jf_UP) * ((1 - px) * u1_main + px * u1_es)

  ##############
  ## Case 2: when credit relationship does not break exogenously

  # 1. the expected repayment for previously unemployed people who retain credit access and :
  # a). tried to find a job that pays w∗
  # b). and end up finding one that pays w∗
  r_hat_u1_c_w2 = jf_UPC * ((1 - px) * r_C_UPC + px * r_C_UPC_es)

  # 2. the expected repayment for previously unemployed people who retain credit access and :
  # a). tried to find a job that pays w∗
  # b). but end up not finding a job and receives unemployment benefits, i.e. γw
  r_hat_u1_c_u1 = (1 - jf_UPC) * ((1 - px) * r_UC + px * r_UC_es)


  qw_negbp = s_bar * (disc) * np.einsum('ij,jkl->ikl', Pi,\
              (r_hat_w1_n_w1 + r_hat_w1_n_u2 + r_hat_w1_n_w2)) +\
               (1-s_bar) * (disc) * np.einsum('ij,jkl->ikl', Pi, \
                (r_hat_w1_c_w1 + r_hat_w1_c_u2 + r_hat_w1_c_w2))

  qu_negbp = s_bar * (disc) * np.einsum('ij,jkl->ikl', Pi,\
   (r_hat_u1_n_w2 + r_hat_u1_n_u1)) + (1-s_bar) * (disc) * \
    np.einsum('ij,jkl->ikl', Pi, (r_hat_u1_c_w2 + r_hat_u1_c_u1))

  return qw_negbp, qu_negbp

def bond_price_def_vec(herkenhoff19_class):
  '''
  This value is the same across all time periods
  '''

  # retrieve parameters from class object
  sig, KD, eta, px, eps_D = herkenhoff19_class.sig, herkenhoff19_class.KD, herkenhoff19_class.eta, herkenhoff19_class.px, herkenhoff19_class.eps_D
  s_bar, bet, delt, rf, tau = herkenhoff19_class.s_bar, herkenhoff19_class.bet, herkenhoff19_class.delt, herkenhoff19_class.rf, herkenhoff19_class.tau
  Pi = herkenhoff19_class.Pi
  b_vec = herkenhoff19_class.b_grid
  r_vec = herkenhoff19_class.r_grid
  T = herkenhoff19_class.T
  Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
      herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)

  NT = T
  Nbp = len(b_vec)

  qwd_mat = np.empty((Ny, Ninc, Nbp, NT))
  qud_mat = np.empty((Ny, Ninc, Nbp, NT))

  bp_grid = b_vec[None, None, :, None]  # shape (1, 1, Nbp, 1)
  bp_mask = np.broadcast_to(bp_grid, (Ny, Ninc, Nbp, NT))

  # Scalar fallback for bp < 0
  qwd_mat[bp_mask < 0] = 0
  qud_mat[bp_mask < 0] = 0

  # Scalar fallback for bp >= 0
  qwd_mat[bp_mask >= 0] = 1 / (1 + rf)
  qud_mat[bp_mask >= 0] = 1 / (1 + rf)

  return qwd_mat, qud_mat

def find_Q(q_mat, qd_mat, EQ_mat, herkenhoff19_class):
  # retrieve variable from class
    s_bar, bet, delt, rf, tau = herkenhoff19_class.s_bar, herkenhoff19_class.bet, herkenhoff19_class.delt, herkenhoff19_class.rf, herkenhoff19_class.tau
    w_vec, z_vec, b_vec, r_vec =  herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
    A = herkenhoff19_class.A
    Y = herkenhoff19_class.Y
    Pi = herkenhoff19_class.Pi
    Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
      herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)

    bp = b_vec[None, None, :, None]              # (1, 1, Nbp, 1)
    r = r_vec[None, None, None, :]               # (1, 1, 1, Nr)
    q = q_mat[:, :, :, None]                     # (Ny, Ninc, Nbp, 1)
    q_d = qd_mat[:, :, :, None]
    EQ = EQ_mat[:, :, :, None]

    Q = np.zeros ((Ny, Ninc, Nb, Nr))

    # set up conditions
    bp_neg = (bp<0)
    bp_pos = ~bp_neg

    r_is_1 = (r==1)
    r_lt_1 = (r<1)

    Q += bp_neg * r_is_1 * (np.abs((tau/(1+rf))*bp*q) +\
     EQ*((1-s_bar)/(1+rf)))

    Q += bp_neg * r_lt_1 * np.abs((tau/(1+rf))*bp*q_d)

    Q += bp_pos * r_is_1 * EQ*((1-s_bar)/(1+rf))

    # when bp is positive and r <1, Q remains 0

    return Q

def EQ_vec (jf_UPC,
      Q_UPC, Q_es_UPC,
       QW, QW_es, QU, QU_es, herkenhoff19_class):

    """

    This function takes in the later period lender's profit from all states and calculated
    the expected value of future lender's profits across all aggregated states

    """
    # retrieve variable from class
    s_bar, rf, x, tau, delt, px = herkenhoff19_class.s_bar, herkenhoff19_class.rf, herkenhoff19_class.x, herkenhoff19_class.tau, herkenhoff19_class.delt, herkenhoff19_class.px
    w_vec, z_vec, b_vec, r_vec =  herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
    b_step = herkenhoff19_class.b_step
    Pi, Y = herkenhoff19_class.Pi, herkenhoff19_class.Y

    ######################### Employed Case ####################################

    QW_hat_w1_w1 = (1-delt) * ((1-px)*QW + px*QW_es)
    QW_hat_w1_u1 = delt * np.multiply( (1-jf_UPC), ((1-px)*QU + px*QU_es) )
    QW_hat_w1_w2 = delt * np.multiply( jf_UPC, ((1-px)*Q_UPC + px*Q_es_UPC) )

    ######################### Unemployed Case ####################################

    QU_hat_u1_w2 = np.multiply( jf_UPC, ((1-px)*Q_UPC + px*Q_es_UPC) )
    QU_hat_u1_u1 = np.multiply( (1-jf_UPC), ((1-px)*QU + px*QU_es) )

    EQW = np.einsum('ij,jkl->ikl', Pi,\
                    (QW_hat_w1_w1 + QW_hat_w1_u1 + QW_hat_w1_w2))
    EQU = np.einsum('ij,jkl->ikl', Pi,\
                    (QU_hat_u1_w2 + QU_hat_u1_u1))

    return EQW, EQU

def A_psi_vec (Q, herkenhoff19_class):

    """

    This function will return the credit finding probability under the employed & unemployed case and whether the household will experience expense shock.

    """

    # retrieve from herkenhoff class
    Kc, zeta_c = herkenhoff19_class.Kc, herkenhoff19_class.zeta_c
    A, Y = herkenhoff19_class.A, herkenhoff19_class.Y
    eps = herkenhoff19_class.eps
    w_vec, z_vec, b_vec, r_vec =  herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
    b_step = herkenhoff19_class.b_step
    Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
      herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)

    AQ = A*Q

    AQ = np.maximum(AQ, eps)

    thet_C = (Kc / AQ)**(-zeta_c) - 1

    thet_C = np.maximum(thet_C, 0)

    thet_C_max = thet_C**(1/zeta_c)

    A_psi = A*(thet_C_max/((thet_C_max**zeta_c+1)**(1/zeta_c)))

    return A_psi

############################### 5. Whether a given household applies for credit access ##################################
def whether_apply_C_vec(VC_max, VN_max, A_psi_max, herkenhoff19_class):

    """

    This function compares households' expected utility given whether they applies for credit.
    Returns a boolean variable that equals 1 if applies and equals 0 if does not apply

    """

    #retrieve variable from class
    chi_c = herkenhoff19_class.chi_c
    w_vec, z_vec, b_vec, r_vec =  herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
    b_step = herkenhoff19_class.b_step
    Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
      herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)

    tbreak = 1.0000e-10

    U_apply_max = A_psi_max*VC_max + (1-A_psi_max)*VN_max - chi_c
    U_do_not_max = VN_max

    c_pol = ((U_apply_max + tbreak) > (U_do_not_max)).astype(int)
    V = np.where(c_pol==1, U_apply_max, U_do_not_max)

    ib = np.arange(Nb)
    ib_es = np.where(ib <= b_step, 0, ib - b_step)

    c_pol_es = c_pol[:,:, ib_es]
    V_es = V[:,:, ib_es]

    return c_pol, c_pol_es, V, V_es

"""**Main Function**"""

def WC_fnc(qw, qw_d, AW_psi, QW, Wold_hat, WCold_hat, V_old, VC_old, herkenhoff19_class):

    """

    This solves the generic utility function for household without expense shock
    To be applied to from period 1 ([0]) to T ([T-1]).

    Returns a U^C, W^C, U^N, and W^N for a given current w (or z), b, y, r&b', and at a given period t

    Input:        emp_          Boolean, employment choice. Default True.
                                emp_ == False for unemployed household, account for leisure and unemployment benefits in this case
                  credit_       Boolean, credit access choice. Default True.
                                credit_ == False for household without credit access, thus their b' is strictly > 0
                  s_bar         Scalar, exogenous credit breaking probability, depends on current default rule
    Output:       V_new        Scalar,  can return WC_t, UC_t, WN_t, or UN_t

    """

    sig, KD, eta, px, eps_D = herkenhoff19_class.sig, herkenhoff19_class.KD, herkenhoff19_class.eta, herkenhoff19_class.px, herkenhoff19_class.eps_D
    s_bar, bet, delt = herkenhoff19_class.s_bar, herkenhoff19_class.bet, herkenhoff19_class.delt
    A = herkenhoff19_class.A
    Y = herkenhoff19_class.Y
    Pi = herkenhoff19_class.Pi
    eps = herkenhoff19_class.eps
    w_vec, z_vec, b_vec, r_vec =  herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
    Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
      herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)
    b_step = herkenhoff19_class.b_step

    Nbp = Nb

    # maximize over combinations of bp and r
    # (Ny, Ninc, Nb, Nbp, Nr)
    b = b_vec[None, None, :, None, None]
    bp = b_vec[None, None, None, :, None]
    r = r_vec[None, None, None, None, :]

    iy = np.arange(Ny)[:, None, None, None, None]
    iw = np.arange(Nw)[None, :, None, None, None]
    ibp = np.arange(Nbp)[None, None, None, :, None]
    ir = np.arange(Nr)[None, None, None, None, :]

    ib = np.arange(Nb)
    ib_es = np.where(ib <= b_step, 0, ib - b_step)

    shape = (Ny, Nw, Nb, Nbp, Nr)

    w = w_vec[None, :, None, None, None]
    q = np.where(r < 1, qw_d[:, :, None, :, None], qw[:, :, None, :, None])

    c = w + r*b - q*bp

    c_cons = np.maximum(c, eps)

    s_d = np.where( (r < 1), 1, s_bar) # if the person defaults, credit relationship breaks up for sure

    EV_1 = np.einsum('ij,jkl->ikl', Pi, ((1-delt)*Wold_hat)) +\
                    np.einsum('ij,jkl->ikl', Pi, (delt*V_old))

    EV_2 = np.einsum('ij,jkl->ikl', Pi, ((1-delt)*WCold_hat)) +\
                np.einsum('ij,jkl->ikl', Pi, (delt*VC_old))

    EV_1 = EV_1[:, :, None, :, None]
    EV_2 = EV_2[:, :, None, :, None]

    V_new = (1-s_d)*bet*EV_2+s_d*bet*EV_1

    uc = (c_cons**(1-sig)-1)/(1-sig)
    xd = KD*((1-r)/(r+eps_D))

    V_new = uc - xd + V_new

    V_new = np.where(c <= 0, V_new - 1e10, V_new)

    b_nonneg_mask = (b_vec >= 0)[None, None, :, None, None]  # shape: (1, 1, Nb, 1, 1)
    mask_invalid_r = b_nonneg_mask & (ir != (Nr - 1))
    V_new = np.where(mask_invalid_r, -1e20, V_new)

    V_new_reshaped = V_new.reshape((Ny, Ninc, Nb, -1))
    WC = np.max(V_new_reshaped, axis=-1)
    idx_max = np.argmax(V_new_reshaped, axis=-1)

    ir_WC = idx_max % Nr
    ibp_WC= idx_max // Nr

    bp_WC = b_vec[ibp_WC]
    r_WC = r_vec[ir_WC]

    WC_es = WC[:, :, ib_es]
    ir_WC_es = ir_WC[:, :, ib_es]
    ibp_WC_es = ibp_WC[:, :, ib_es]
    r_WC_es = r_WC[:, :, ib_es]
    bp_WC_es = bp_WC[:, :, ib_es]

    iy = np.arange(Ny)[:, None, None]      # shape (Ny, 1, 1)
    iw = np.arange(Nw)[None, :, None]

    AW_psi_max = AW_psi[iy, iw , ibp_WC, ir_WC]
    QW_max = QW[iy, iw , ibp_WC, ir_WC]

    AW_psi_es_max = AW_psi_max[iy, iw , ib_es]
    QW_es_max = QW_max[iy, iw , ib_es]

    return WC, WC_es, ir_WC, ibp_WC, r_WC, bp_WC, ir_WC_es, ibp_WC_es, r_WC_es, bp_WC_es,\
     AW_psi_max, QW_max, AW_psi_es_max, QW_es_max

def WN_fnc(qw, qw_d, AW_psi, QW, Wold_hat, V_old, herkenhoff19_class):

    """

    This solves the generic utility function for household without expense shock
    To be applied to from period 1 ([0]) to T ([T-1]).

    Returns a U^C, W^C, U^N, and W^N for a given current w (or z), b, y, r&b', and at a given period t

    Input:        emp_          Boolean, employment choice. Default True.
                                emp_ == False for unemployed household, account for leisure and unemployment benefits in this case
                  credit_       Boolean, credit access choice. Default True.
                                credit_ == False for household without credit access, thus their b' is strictly > 0
                  s_bar         Scalar, exogenous credit breaking probability, depends on current default rule
    Output:       V_new        Scalar,  can return WC_t, UC_t, WN_t, or UN_t

    """

    sig, KD, eta, px, eps_D = herkenhoff19_class.sig, herkenhoff19_class.KD, herkenhoff19_class.eta, herkenhoff19_class.px, herkenhoff19_class.eps_D
    s_bar, bet, delt = herkenhoff19_class.s_bar, herkenhoff19_class.bet, herkenhoff19_class.delt
    A = herkenhoff19_class.A
    Y = herkenhoff19_class.Y
    Pi = herkenhoff19_class.Pi
    eps = herkenhoff19_class.eps
    w_vec, z_vec, b_vec, r_vec =  herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
    Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
      herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)
      
    b_step = herkenhoff19_class.b_step

    Nbp = Nb

    # maximize over combinations of bp and r
    # (Ny, Ninc, Nb, Nbp, Nr)
    b = b_vec[None, None, :, None, None]
    bp = b_vec[None, None, None, :, None]
    r = r_vec[None, None, None, None, :]

    iy = np.arange(Ny)[:, None, None, None, None]
    iw = np.arange(Nw)[None, :, None, None, None]
    ibp = np.arange(Nbp)[None, None, None, :, None]
    ir = np.arange(Nr)[None, None, None, None, :]

    ib = np.arange(Nb)
    ib_es = np.where(ib <= b_step, 0, ib - b_step)

    shape = (Ny, Nw, Nb, Nbp, Nr)

    w = w_vec[None, :, None, None, None]
    q = qw[:, :, None, :, None]

    c = w + r*b - q*bp

    c = np.where(bp < 0, c - 1e10, c)

    c_cons = np.maximum(c, eps)

    EV = np.einsum('ij,jkl->ikl', Pi, ((1-delt)*Wold_hat)) +\
            np.einsum('ij,jkl->ikl', Pi, (delt*V_old))

    EV = EV[:, :, None, :, None]

    V_new = bet*EV

    uc = (c_cons**(1-sig)-1)/(1-sig)
    xd = KD*((1-r)/(r+eps_D))

    V_new = uc - xd + V_new

    V_new = np.where(c <= 0, V_new - 1e10, V_new)

    b_nonneg_mask = (b_vec >= 0)[None, None, :, None, None]  # shape: (1, 1, Nb, 1, 1)
    mask_invalid_r = b_nonneg_mask & (ir != (Nr - 1))
    V_new = np.where(mask_invalid_r, -1e20, V_new)

    V_new_reshaped = V_new.reshape((Ny, Ninc, Nb, -1))
    WN = np.max(V_new_reshaped, axis=-1)
    idx_max = np.argmax(V_new_reshaped, axis=-1)

    ir_WN = idx_max % Nr
    ibp_WN = idx_max // Nr

    bp_WN = b_vec[ibp_WN]
    r_WN = r_vec[ir_WN]

    WN_es = WN[:, :, ib_es]
    ir_WN_es = ir_WN[:, :, ib_es]
    ibp_WN_es = ibp_WN[:, :, ib_es]
    r_WN_es = r_WN[:, :, ib_es]
    bp_WN_es = bp_WN[:, :, ib_es]

    return WN, WN_es, ir_WN, ibp_WN, r_WN, bp_WN, ir_WN_es, ibp_WN_es, r_WN_es, bp_WN_es

def UC_fnc(qu, qu_d, AU_psi, QU, V_old, VC_old, herkenhoff19_class):

    """

    This solves the generic utility function for household without expense shock
    To be applied to from period 1 ([0]) to T ([T-1]).

    Returns a U^C, W^C, U^N, and W^N for a given current w (or z), b, y, r&b', and at a given period t

    Input:        emp_          Boolean, employment choice. Default True.
                                emp_ == False for unemployed household, account for leisure and unemployment benefits in this case
                  credit_       Boolean, credit access choice. Default True.
                                credit_ == False for household without credit access, thus their b' is strictly > 0
                  s_bar         Scalar, exogenous credit breaking probability, depends on current default rule
    Output:       V_new        Scalar,  can return WC_t, UC_t, WN_t, or UN_t

    """

    sig, KD, eta, px, eps_D = herkenhoff19_class.sig, herkenhoff19_class.KD, herkenhoff19_class.eta, herkenhoff19_class.px, herkenhoff19_class.eps_D
    s_bar, bet, delt = herkenhoff19_class.s_bar, herkenhoff19_class.bet, herkenhoff19_class.delt
    A = herkenhoff19_class.A
    Y = herkenhoff19_class.Y
    Pi = herkenhoff19_class.Pi
    eps = herkenhoff19_class.eps
    w_vec, z_vec, b_vec, r_vec =  herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
    Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
      herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)
    b_step = herkenhoff19_class.b_step
    Nbp = Nb

    # maximize over combinations of bp and r
    # (Ny, Ninc, Nb, Nbp, Nr)
    b = b_vec[None, None, :, None, None]
    bp = b_vec[None, None, None, :, None]
    r = r_vec[None, None, None, None, :]

    iy = np.arange(Ny)[:, None, None, None, None]
    iw = np.arange(Nw)[None, :, None, None, None]
    ibp = np.arange(Nbp)[None, None, None, :, None]
    ir = np.arange(Nr)[None, None, None, None, :]

    ib = np.arange(Nb)
    ib_es = np.where(ib <= b_step, 0, ib - b_step)

    shape = (Ny, Nw, Nb, Nbp, Nr)

    z = z_vec[None, :, None, None, None]
    q = np.where(r < 1, qu_d[:, :, None, :, None], qu[:, :, None, :, None])

    c = z + r*b - q*bp

    c_cons = np.maximum(c, eps)

    s_d = np.where( (r < 1), 1, s_bar) # if the person defaults, credit relationship breaks up for sure

    EV_1 = np.einsum('ij,jkl->ikl', Pi, V_old)

    EV_2 = np.einsum('ij,jkl->ikl', Pi, VC_old)

    EV_1 = EV_1[:, :, None, :, None]
    EV_2 = EV_2[:, :, None, :, None]

    V_new = eta + (1-s_d)*bet*EV_2+s_d*bet*EV_1

    uc = (c_cons**(1-sig)-1)/(1-sig)
    xd = KD*((1-r)/(r+eps_D))

    V_new = uc - xd + V_new

    V_new = np.where(c <= 0, V_new - 1e10, V_new)

    b_nonneg_mask = (b_vec >= 0)[None, None, :, None, None]  # shape: (1, 1, Nb, 1, 1)
    mask_invalid_r = b_nonneg_mask & (ir != (Nr - 1))
    V_new = np.where(mask_invalid_r, -1e20, V_new)

    V_new_reshaped = V_new.reshape((Ny, Ninc, Nb, -1))
    UC = np.max(V_new_reshaped, axis=-1)
    idx_max = np.argmax(V_new_reshaped, axis=-1)

    ir_UC = idx_max % Nr
    ibp_UC = idx_max // Nr

    bp_UC = b_vec[ibp_UC]
    r_UC = r_vec[ir_UC]

    UC_es = UC[:, :, ib_es]
    ir_UC_es = ir_UC[:, :, ib_es]
    ibp_UC_es = ibp_UC[:, :, ib_es]
    r_UC_es = r_UC[:, :, ib_es]
    bp_UC_es = bp_UC[:, :, ib_es]

    iy = np.arange(Ny)[:, None, None]      # shape (Ny, 1, 1)
    iw = np.arange(Nw)[None, :, None]

    AU_psi_max = AU_psi[iy, iw , ibp_UC, ir_UC]
    QU_max = QU[iy, iw ,  ibp_UC, ir_UC]

    AU_psi_es_max = AU_psi_max[iy, iw , ib_es]
    QU_es_max = QU_max[iy, iw , ib_es]

    return UC, UC_es, ir_UC, ibp_UC, r_UC, bp_UC, ir_UC_es, ibp_UC_es, r_UC_es, bp_UC_es,\
     AU_psi_max, QU_max, AU_psi_es_max, QU_es_max

def UN_fnc(qu, qu_d, AU_psi, QU, V_old, herkenhoff19_class):

    """

    This solves the generic utility function for household without expense shock
    To be applied to from period 1 ([0]) to T ([T-1]).

    Returns a U^C, W^C, U^N, and W^N for a given current w (or z), b, y, r&b', and at a given period t

    Input:        emp_          Boolean, employment choice. Default True.
                                emp_ == False for unemployed household, account for leisure and unemployment benefits in this case
                  credit_       Boolean, credit access choice. Default True.
                                credit_ == False for household without credit access, thus their b' is strictly > 0
                  s_bar         Scalar, exogenous credit breaking probability, depends on current default rule
    Output:       V_new        Scalar,  can return WC_t, UC_t, WN_t, or UN_t

    """

    sig, KD, eta, px, eps_D = herkenhoff19_class.sig, herkenhoff19_class.KD, herkenhoff19_class.eta, herkenhoff19_class.px, herkenhoff19_class.eps_D
    s_bar, bet, delt = herkenhoff19_class.s_bar, herkenhoff19_class.bet, herkenhoff19_class.delt
    A = herkenhoff19_class.A
    Y = herkenhoff19_class.Y
    Pi = herkenhoff19_class.Pi
    eps = herkenhoff19_class.eps
    w_vec, z_vec, b_vec, r_vec =  herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
    Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
      herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)
      
    b_step = herkenhoff19_class.b_step

    Nbp = Nb

    # maximize over combinations of bp and r
    # (Ny, Ninc, Nb, Nbp, Nr)
    b = b_vec[None, None, :, None, None]
    bp = b_vec[None, None, None, :, None]
    r = r_vec[None, None, None, None, :]

    iy = np.arange(Ny)[:, None, None, None, None]
    iw = np.arange(Nw)[None, :, None, None, None]
    ibp = np.arange(Nbp)[None, None, None, :, None]
    ir = np.arange(Nr)[None, None, None, None, :]

    ib = np.arange(Nb)
    ib_es = np.where(ib <= b_step, 0, ib - b_step)

    shape = (Ny, Nw, Nb, Nbp, Nr)

    z = z_vec[None, :, None, None, None]
    q = qu[:, :, None, :, None]

    c = z + r*b - q*bp

    c = np.where(bp < 0, c - 1e10, c)

    c_cons = np.maximum(c, eps)

    EV = np.einsum('ij,jkl->ikl', Pi, V_old)

    V_new = eta+ bet*EV[:, :, None, :, None]

    uc = (c_cons**(1-sig)-1)/(1-sig)
    xd = KD*((1-r)/(r+eps_D))

    V_new = uc - xd + V_new

    V_new = np.where(c <= 0, V_new - 1e10, V_new)

    b_nonneg_mask = (b_vec >= 0)[None, None, :, None, None]  # shape: (1, 1, Nb, 1, 1)
    mask_invalid_r = b_nonneg_mask & (ir != (Nr - 1))
    V_new = np.where(mask_invalid_r, -1e20, V_new)

    V_new_reshaped = V_new.reshape((Ny, Ninc, Nb, -1))
    UN = np.max(V_new_reshaped, axis=-1)
    idx_max = np.argmax(V_new_reshaped, axis=-1)

    ir_UN = idx_max % Nr
    ibp_UN = idx_max // Nr

    bp_UN = b_vec[ibp_UN]
    r_UN = r_vec[ir_UN]

    UN_es = UN[:, :, ib_es]
    ir_UN_es = ir_UN[:, :, ib_es]
    ibp_UN_es = ibp_UN[:, :, ib_es]
    r_UN_es = r_UN[:, :, ib_es]
    bp_UN_es = bp_UN[:, :, ib_es]

    return UN, UN_es, ir_UN, ibp_UN, r_UN, bp_UN, ir_UN_es, ibp_UN_es, r_UN_es, bp_UN_es

def VP_mat(t, pt, r_WC, r_WC_es, r_WN, r_WN_es,\
           WC, WC_es, W, W_es, UC, UC_es, U, U_es,
           AW_psi_max, QW_max, AW_psi_es_max,
           c_pol_w, c_pol_w_es, herkenhoff19_class):

    # Retrieve variables from class
    sig, KD, eta, px, eps_D = herkenhoff19_class.sig, herkenhoff19_class.KD, herkenhoff19_class.eta, herkenhoff19_class.px, herkenhoff19_class.eps_D
    s_bar, bet, delt = herkenhoff19_class.s_bar, herkenhoff19_class.bet, herkenhoff19_class.delt
    w_vec, z_vec, b_vec, r_vec =  herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
    b_step = herkenhoff19_class.b_step
    A = herkenhoff19_class.A
    Y = herkenhoff19_class.Y
    Pi = herkenhoff19_class.Pi
    T = herkenhoff19_class.T
    Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
      herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)

    # find hatted value
    WC_hat = px*WC_es + (1-px)*WC
    W_hat =  px*W_es + (1-px)*W
    UC_hat = px*UC_es + (1-px)*UC
    U_hat = px*U_es + (1-px)*U

    # job finding probability
    jf_rate = pt[:,:,t]

    # Nyp, Nwp, Nz, Nb
    jf_rate_exp = jf_rate[:, :, None, None]  # Nyp, Nwp, 1, 1
    jf_rate_exp = np.repeat(np.repeat(jf_rate_exp, Nz, axis=2), Nb, axis=3)

    jf_rate_short = jf_rate[:, :,  None]
    jf_rate_short = np.repeat(jf_rate_short, Nb, axis=2)

    W_hat_exp = W_hat[:, :, None, :]   # Nyp, Nwp, 1, Nbp
    U_hat_exp = U_hat[:, None, :, :]   # Nyp, 1, Nz, Nbp
    WC_hat_exp = WC_hat[:, :, None, :]
    UC_hat_exp = UC_hat[:, None, :, :]

    UP = jf_rate_exp*W_hat_exp + (1-jf_rate_exp)*U_hat_exp
    UPC = jf_rate_exp*WC_hat_exp + (1-jf_rate_exp)*UC_hat_exp

    # Max over Nw (axis=1)
    UP_max = np.max(UP, axis=1) # Nyp, Nz, Nbp
    UPC_max = np.max(UPC, axis=1)
    iw_max = np.argmax(UP, axis=1)
    iwc_max = np.argmax(UPC, axis=1)

    iyp = np.arange(Ny)[:, None, None]      # shape: (Ny, 1, 1)
    ibp = np.arange(Nb)[None, None, :]      # shape: (1, 1, Nb)

    r_N_UP = r_WN[iyp, iw_max, ibp]
    r_C_UP = r_WC[iyp, iw_max, ibp]
    r_C_UPC = r_WC[iyp, iwc_max, ibp]

    A_psi_UP = AW_psi_max[iyp, iw_max, ibp]
    A_psi_UPC = AW_psi_max[iyp, iwc_max, ibp]
    Q_UPC = QW_max[iyp, iwc_max, ibp]
    jf_UP = jf_rate_short[iyp, iw_max, ibp]
    jf_UPC = jf_rate_short[iyp, iwc_max, ibp]

    w_UP = w_vec[iw_max]
    w_UPC = w_vec[iwc_max]

    c_pol_UP = c_pol_w[iyp, iwc_max, ibp]

    # expense shock case
    ibp_es = np.where(ibp <= b_step, 0, ibp - b_step)

    r_N_UP_es = r_WN[iyp, iw_max, ibp_es]
    r_C_UP_es = r_WC[iyp, iw_max, ibp_es]
    r_C_UPC_es = r_WC[iyp, iwc_max, ibp_es]

    A_psi_UP_es = AW_psi_max[iyp, iw_max, ibp_es]
    A_psi_UPC_es = AW_psi_max[iyp, iwc_max, ibp_es]
    Q_UPC_es = QW_max[iyp, iwc_max, ibp_es]
    jf_UP_es = jf_rate_short[iyp, iw_max, ibp_es]
    jf_UPC_es = jf_rate_short[iyp, iwc_max, ibp_es]

    c_pol_UP_es = c_pol_w[iyp, iwc_max, ibp_es]

    return W_hat, WC_hat, UP_max, UPC_max, iw_max, iwc_max, r_N_UP,\
     r_C_UP, r_C_UPC, A_psi_UP, A_psi_UPC, Q_UPC, jf_UP,\
      jf_UPC, w_UP, w_UPC, c_pol_UP, r_N_UP_es, r_C_UP_es,\
      r_C_UPC_es, A_psi_UP_es, A_psi_UPC_es, Q_UPC_es, jf_UP_es,\
       jf_UPC_es, c_pol_UP_es, w_UP, w_UPC

"""# Main Iteration"""

def V_iter(herkenhoff19_class):
  sig, KD, eta, px, eps_D = herkenhoff19_class.sig, herkenhoff19_class.KD, herkenhoff19_class.eta, herkenhoff19_class.px, herkenhoff19_class.eps_D
  s_bar, bet, delt = herkenhoff19_class.s_bar, herkenhoff19_class.bet, herkenhoff19_class.delt
  w_vec, z_vec, b_vec, r_vec =  herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
  b_step = herkenhoff19_class.b_step
  A = herkenhoff19_class.A
  Y = herkenhoff19_class.Y
  Pi = herkenhoff19_class.Pi
  T = herkenhoff19_class.T
  Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
    herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)

  # set up auxiliary variables
  NT = T
  Nbp = Nb

  shape = (Ny, Ninc, Nb, NT)
  shape_bp = (Ny, Ninc, Nbp, Nr, NT)

  def create_storage_vars():
        return {name: np.zeros(shape) for name in [
            "A_psi_w", "A_psi_u",  'A_psi_w_es', 'A_psi_u_es',
            "c_pol_w", "c_pol_u", "c_pol_u_es", 'c_pol_UP', 'c_pol_UP_es',
            "A_psi_UP", "A_psi_UPC", 'A_psi_UP_es', 'A_psi_UPC_es',
            "QW", "QU", "QW_es", "QU_es",
            "Q_UPC", "Q_UPC_es",
            'qw',  'qu',
            "W", "WC", "WN", "U", "UC", "UN", "W_hat", "WC_hat",
            'UP', 'UPC',
            "bp_WC", "bp_WN", "bp_UC", "bp_UN",
            "ibp_WC", "ibp_WN", "ibp_UC", "ibp_UN",
            "r_WC", "r_WN", "r_UC", "r_UN",
            "r_WC_es", "r_WN_es", "r_UN_es", "r_UC_es",
            "ir_WC", "ir_WN", "ir_UC", "ir_UN",
            "jf_UP", "jf_UPC",
            "r_C_UP",  "r_N_UP", "r_C_UPC",
            "r_C_UP_es",  "r_N_UP_es",  "r_C_UPC_es",
            "w_UP", "w_UPC",
            "iw_max", "iwc_max"]}

  # Initialize storage dictionaries
  storage_vars = create_storage_vars()

  ########################################################################################
  ######################## Get Job Finding Probability ###################################
  Jt_mat, pt, thet_mat = J_VFI(herkenhoff19_class)

  ########################################################################################
  ################### qwd and qud are consistent across periods ##########################
  qwd, qud = bond_price_def_vec(herkenhoff19_class)
  qwd_raw, qud_raw = qwd[:,:,:,0], qud[:,:,:,0]

  ########################################################################################
  ############################# Iterate for Household ####################################
  # solve for last period first
  # print("Solving for period " + str(119))
  (W, WC, WN, U, UC, UN,
        W_hat, WC_hat,
        ir_WC, ir_WN, ir_UC, ir_UN,
        r_WN, r_WN_es, r_WC, r_WC_es,
        r_UN, r_UN_es, r_UC, r_UC_es,
        r_N_UP, r_N_UP_es, r_C_UP, r_C_UP_es,
        r_C_UPC, r_C_UPC_es,
        iw_max, iwc_max,
        jf_UP, jf_UPC, UP, UPC,  w_UP, w_UPC) = VPT_mat(pt, herkenhoff19_class)

  # Store final period values
  for name in storage_vars:
      if name in locals():
          # print(f"Storing {name}")
          storage_vars[name][:, :, :, -1] = eval(name).copy()

  for var in ["ibp_WC", "ibp_WN", "ibp_UC", "ibp_UN"]:
      storage_vars[var][:, :, :, -1] = 13
  for var in ["bp_WC", "bp_WN", "bp_UC", "bp_UN"]:
      storage_vars[var][:, :, :, -1] = 0

  # solve for all prior periods
  t = T-2
  while t >= 0:
    # print("Solving for period " + str(t))

    def get_previous(name, t, storage_vars):
      if name in storage_vars:
          return storage_vars[name][:, :, :, t + 1]
      else:
          raise KeyError(f"'{name}' not found in storage_vars.")

    c_pol_w_old, c_pol_u_old, c_pol_u_es_old,\
          c_pol_UP_old, c_pol_UP_es_old,\
          A_psi_w_old, A_psi_u_old, A_psi_w_es_old, A_psi_u_es_old,\
          A_psi_UP_old, A_psi_UP_es_old, A_psi_UPC_old, A_psi_UPC_es_old,\
          r_WN_old, r_WN_es_old, r_WC_old, r_WC_es_old,\
          r_UN_old, r_UN_es_old, r_UC_old, r_UC_es_old,\
          r_N_UP_old, r_N_UP_es_old, r_C_UP_old, r_C_UP_es_old,\
          r_C_UPC_old, r_C_UPC_es_old,\
          jf_UP_old, jf_UPC_old,\
          Q_UPC_old, Q_UPC_es_old, QW_old, QW_es_old, QU_old, QU_es_old,\
          Wold_hat, WCold_hat, V_old, VC_old =\
           (get_previous('c_pol_w', t, storage_vars), get_previous('c_pol_u', t, storage_vars),
            get_previous('c_pol_u_es', t, storage_vars),get_previous('c_pol_UP', t, storage_vars),
            get_previous('c_pol_UP_es', t, storage_vars),
            get_previous('A_psi_w', t, storage_vars),get_previous('A_psi_u', t, storage_vars),
            get_previous('A_psi_w_es', t, storage_vars), get_previous('A_psi_u_es', t, storage_vars),
            get_previous('A_psi_UP', t, storage_vars), get_previous('A_psi_UP_es', t, storage_vars),
            get_previous('A_psi_UPC', t, storage_vars), get_previous('A_psi_UPC_es', t, storage_vars),
            get_previous('r_WN', t, storage_vars), get_previous('r_WN_es', t, storage_vars),
            get_previous('r_WC', t, storage_vars), get_previous('r_WC_es', t, storage_vars),
            get_previous('r_UN', t, storage_vars), get_previous('r_UN_es', t, storage_vars),
            get_previous('r_UC', t, storage_vars), get_previous('r_UC_es', t, storage_vars),
            get_previous('r_N_UP', t, storage_vars), get_previous('r_N_UP_es', t, storage_vars),
            get_previous('r_C_UP', t, storage_vars), get_previous('r_C_UP_es', t,storage_vars),
            get_previous('r_C_UPC', t, storage_vars), get_previous('r_C_UPC_es', t, storage_vars),
            get_previous('jf_UP', t, storage_vars), get_previous('jf_UPC', t, storage_vars),
            get_previous('Q_UPC', t, storage_vars), get_previous('Q_UPC_es', t, storage_vars),
            get_previous('QW', t, storage_vars), get_previous('QW_es', t, storage_vars),
            get_previous('QU', t, storage_vars), get_previous('QU_es', t, storage_vars),
            get_previous('W_hat', t, storage_vars), get_previous('WC_hat', t, storage_vars),
            get_previous('UP', t, storage_vars), get_previous('UPC', t, storage_vars))

    qw, qu = bond_price_nodef_vec(c_pol_w_old, c_pol_u_old, c_pol_u_es_old,
                              c_pol_UP_old, c_pol_UP_es_old,
                              A_psi_w_old, A_psi_u_old, A_psi_w_es_old, A_psi_u_es_old,
                              A_psi_UP_old, A_psi_UP_es_old, A_psi_UPC_old, A_psi_UPC_es_old,
                              r_WN_old, r_WN_es_old, r_WC_old, r_WC_es_old,
                              r_UN_old, r_UN_es_old, r_UC_old, r_UC_es_old,
                              r_N_UP_old, r_N_UP_es_old, r_C_UP_old, r_C_UP_es_old,
                              r_C_UPC_old, r_C_UPC_es_old,
                              jf_UP_old, jf_UPC_old,
                              herkenhoff19_class)

    EQW_raw, EQU_raw = EQ_vec (jf_UPC_old, Q_UPC_old, Q_UPC_es_old, QW_old, QW_es_old,\
                        QU_old, QU_es_old, herkenhoff19_class)

    QW_raw = find_Q(qw, qwd_raw, EQW_raw, herkenhoff19_class)
    QU_raw = find_Q(qu, qud_raw, EQU_raw, herkenhoff19_class)

    A_psi_w_raw = A_psi_vec (QW_raw, herkenhoff19_class)
    A_psi_u_raw = A_psi_vec (QU_raw, herkenhoff19_class)

    WC, WC_es, ir_WC, ibp_WC, r_WC, bp_WC, ir_WC_es, ibp_WC_es, r_WC_es, bp_WC_es,\
     A_psi_w, QW, A_psi_w_es, QW_es = \
                WC_fnc(qw, qwd_raw, A_psi_w_raw, QW_raw, Wold_hat, WCold_hat, V_old, VC_old, herkenhoff19_class)

    WN, WN_es, ir_WN, ibp_WN, r_WN, bp_WN, ir_WN_es, ibp_WN_es, r_WN_es, bp_WN_es =\
                WN_fnc(qw, qwd_raw, A_psi_w_raw, QW_raw, Wold_hat, V_old, herkenhoff19_class)

    UC, UC_es, ir_UC, ibp_UC, r_UC, bp_UC, ir_UC_es, ibp_UC_es, r_UC_es, bp_UC_es,\
     A_psi_u, QU, A_psi_u_es, QU_es = \
                UC_fnc(qu, qud_raw, A_psi_u_raw, QU_raw, V_old, VC_old, herkenhoff19_class)

    UN, UN_es, ir_UN, ibp_UN, r_UN, bp_UN, ir_UN_es, ibp_UN_es, r_UN_es, bp_UN_es = \
                UN_fnc(qu, qud_raw, A_psi_u_raw, QU_raw, V_old, herkenhoff19_class)

    c_pol_w, c_pol_w_es, W, W_es = whether_apply_C_vec(WC, WN, A_psi_w, herkenhoff19_class)
    c_pol_u, c_pol_u_es, U, U_es = whether_apply_C_vec(UC, UN, A_psi_u, herkenhoff19_class)

    W_hat, WC_hat, UP, UPC, iw_max, iwc_max, r_N_UP,\
     r_C_UP, r_C_UPC, A_psi_UP, A_psi_UPC, Q_UPC, jf_UP,\
      jf_UPC, w_UP, w_UPC, c_pol_UP, r_N_UP_es, r_C_UP_es,\
      r_C_UPC_es, A_psi_UP_es, A_psi_UPC_es, Q_UPC_es, jf_UP_es,\
       jf_UPC_es, c_pol_UP_es, w_UP, w_UPC = VP_mat(t, pt, r_WC, r_WC_es, r_WN, r_WN_es,\
                            WC, WC_es, W, W_es, UC, UC_es, U, U_es,
                            A_psi_w, QW, A_psi_w_es,
                            c_pol_w, c_pol_w_es, herkenhoff19_class)

    for name in storage_vars:
      if name in locals():
          storage_vars[name][:, :, :, t] = eval(name).copy()

    t-=1

  storage_vars['qwd'] = qwd
  storage_vars['qud'] = qud
  storage_vars['pt'] = pt

  return storage_vars

"""# Simulation

**Simulation Functions**



1.   PDF Simulation
2.   Markov Chain Simulation

**Simulation Functions**
"""

# Markov Sim
# Takes in a uniform random number x, a transition matrix P, and a previous state i, and spits out the next state j

# input:    ydraw:    N_T_econ X 1. Each element is a random number between 0 and 1
#               P:    Ny * Ny. A conditional probability transitional matrix for labour productivity
#               Y:    labor productivity

def markovsim_scalar(iy, iT, ydraw, P, herkenhoff19_class):

    # set auxiliary variable
    xi = ydraw[iT]

    # get conditional CDF given each state
    Psum = np.cumsum(P, axis=1)
    n=len(Psum)

    for i in range(n-1):
        if (xi >= Psum[iy, i]) & (xi < Psum[iy, i+1]):
            j=i+1

    if xi < Psum[iy, 0]:
        j=0

    return j

def markovsim_iter(iy_init, ydraw, P, Y, herkenhoff19_class):

    N = herkenhoff19_class.N
    T_econ = herkenhoff19_class.T_econ

    # initialize vectors
    iagg_state = np.zeros((T_econ))

    # loop through the entire economy
    iagg_state[0]  = iy_init
    iy_old = iy_init
    iT = 1
    while iT < T_econ:
        iy_new = markovsim_scalar(iy_old, iT, ydraw, P, herkenhoff19_class)
        iagg_state[iT]  = int(iy_new)
        iy_old = iy_new
        iT += 1

    return iagg_state

def pdfsim_vectorized(X_rand, P):
    # shape: (N,)
    cdf = np.cumsum(P)
    indices = np.searchsorted(cdf, X_rand, side='right')
    return np.clip(indices, 0, len(P) - 1)

def vectorized_simulation(T_econ, N, P_w_init, P_e_init, P_a_init,\
                          pt, ia_draw, iw_draw, ie_draw, if_draw, ic_draw,\
                          ies_draw, idc_draw, iy_init, y_draw, iw_til_UP_mat, iw_til_UPC_mat,
                          A_psi_w_all_mat, A_psi_u_all_mat, c_pol_w_all_mat, c_pol_u_all_mat,
                          ibp_WC_mat, ibp_WN_mat, ibp_UC_mat, ibp_UN_mat, ir_WC_mat, ir_WN_mat,\
                          ir_UC_mat, ir_UN_mat,qw_all_mat, qu_all_mat, qw_d_all_mat, qu_d_all_mat,\
                          herkenhoff19_class):

  sig, KD, eta, px, eps_D = herkenhoff19_class.sig, herkenhoff19_class.KD, herkenhoff19_class.eta, herkenhoff19_class.px, herkenhoff19_class.eps_D
  s_bar, bet, delt = herkenhoff19_class.s_bar, herkenhoff19_class.bet, herkenhoff19_class.delt
  w_vec, z_vec, b_vec, r_vec =  herkenhoff19_class.w_grid, herkenhoff19_class.z_grid, herkenhoff19_class.b_grid, herkenhoff19_class.r_grid
  b_step = herkenhoff19_class.b_step
  A = herkenhoff19_class.A
  Y = herkenhoff19_class.Y
  Pi = herkenhoff19_class.Pi
  T = herkenhoff19_class.T
  Nw, Nz, Ninc, Nb, Nr, Ny = (herkenhoff19_class.Nw, herkenhoff19_class.Nz,
    herkenhoff19_class.Ninc, herkenhoff19_class.Nb, herkenhoff19_class.Nr, herkenhoff19_class.Ny)

  # compute aggregate states
  iagg_state = markovsim_iter(iy_init, y_draw, Pi, Y, herkenhoff19_class)
  # set auxiliary variables to store simulated indexes
  ie_sim_mat = np.zeros((T_econ, N), dtype=int)
  iw_sim_mat = np.zeros((T_econ, N), dtype=int)
  ib_sim_mat = np.zeros((T_econ, N), dtype=int) # ibp
  ic_sim_mat = np.zeros((T_econ, N), dtype=int)
  ic_cont_sim_mat = np.zeros((T_econ, N), dtype=int)
  ia_sim_mat = np.zeros((T_econ, N), dtype=int)
  ir_sim_mat = np.zeros((T_econ, N), dtype=int)
  q_sim_mat = np.zeros((T_econ, N))
  c_sim_mat = np.zeros((T_econ, N))
  fireslot_sim_mat = np.zeros((T_econ, N), dtype=int)
  mslot_sim_mat = np.zeros((T_econ, N), dtype=int)
  sbar_sim_mat = np.zeros((T_econ, N), dtype=int)
  expense_shock_sim_mat = np.zeros((T_econ, N), dtype=int)
  c_pol_sim_mat = np.zeros((T_econ, N))
  A_psi_sim_mat = np.zeros((T_econ, N))
  ie_old_sim_mat = np.zeros((T_econ, N), dtype=int)
  iw_old_sim_mat = np.zeros((T_econ, N), dtype=int)
  ib_old_sim_mat = np.zeros((T_econ, N), dtype=int) # realized ib
  ic_old_sim_mat = np.zeros((T_econ, N), dtype=int)

  # Initialization (t = 0)
  # start with the first period in the economy
  # where iT_econ = 0
  # initialize individual states for iT_econ = 0
  iw_sim_mat[0, :] = pdfsim_vectorized(iw_draw[0,:], P_w_init).astype(int)
  ie_sim_mat[0, :] = pdfsim_vectorized(ie_draw[0,:], P_e_init).astype(int)
  ie_sim_mat[0, :] = ie_sim_mat[0, :] + 1.
  ie_sim_mat[0, :][ie_sim_mat[0, :]== 2] = 0.
  ia_sim_mat[0, :] = pdfsim_vectorized(ia_draw[0,:], P_a_init).astype(int)
  ib_sim_mat[0, :] = 13.
  ir_sim_mat[0, :] = Nr - 1

  for t in range(1, T_econ):
    # print("Economy Period: " + str(t))
    iy = np.repeat(iagg_state[t], N).astype(int)
    ia_sim_mat[t, :] = ((ia_sim_mat[t - 1, :] + 1) % T)
    ia_sim_mat[t, :] = ia_sim_mat[t, :].astype(int)

    # Copy over previous if not reset
    ie = ie_sim_mat[t - 1, :].astype(int)
    iw = iw_sim_mat[t - 1, :].astype(int)
    ib = ib_sim_mat[t - 1, :].astype(int)
    ir = ir_sim_mat[t - 1, :].astype(int)
    ic_cont = ic_cont_sim_mat[t - 1, :].astype(int)
    ic = ic_cont_sim_mat[t - 1, :].astype(int)

    # Reset conditions
    is_reset = (ia_sim_mat[t, :].astype(int) == 0) # if ia == T
    ie[is_reset] = pdfsim_vectorized(ie_draw[t, is_reset], P_e_init).astype(int)
    ie[is_reset] = ie[is_reset] + 1.
    ie[is_reset] = np.where(ie[is_reset] == 2, 0, ie[is_reset])
    iw[is_reset] = pdfsim_vectorized(iw_draw[t, is_reset], P_w_init).astype(int)
    ib[is_reset] = 13.
    ir[is_reset] = Nr - 1
    ic[is_reset] = 0.
    ic_cont[is_reset] = 0.

    # Determine job status
    #  # If household i found a job last period (i.e., eold = W ), decide whether this household i experiences job loss
    employed = (ie.astype(int) == 1)
    retained = (employed & (if_draw[t, :] <= (1 - delt))) # 1- delt is the probability that one retains their job
    fired = employed & (~(if_draw[t, :] <= (1 - delt)))

    ie_sim_mat[t, retained] = 1
    fireslot_sim_mat[t, retained] = 1
    iw_sim_mat[t, retained] = iw[retained]
    mslot_sim_mat[t, retained] = 0

    iw_til = np.where(
            ic == 1,
            iw_til_UPC_mat[(iy, iw, ib, ia_sim_mat[t, :])].astype(int),
            iw_til_UP_mat[(iy, iw, ib, ia_sim_mat[t, :])].astype(int)
        ).astype(int)

    fireslot_sim_mat[t, fired] = 2

    # find the job finding probability corresponding to the desired wage
    finds_job = (iw_draw[t, :] <= pt[iy, iw_til, ia_sim_mat[t, :]])

    mslot_sim_mat[t, fired & finds_job] = 1
    ie_sim_mat[t, fired & finds_job] = 1
    iw_sim_mat[t,  fired & finds_job] = iw_til[fired & finds_job]

    mslot_sim_mat[t, fired & (~finds_job)] = 2
    ie_sim_mat[t, fired & (~finds_job)] = 0
    iw_sim_mat[t,  fired & (~finds_job)] = iw[fired & (~finds_job)]

    # If the individual is unemployed last period
    unemployed = (ie.astype(int) == 0)
    mslot_sim_mat[t, unemployed & (finds_job)] = 1
    ie_sim_mat[t, unemployed & (finds_job)] = 1
    iw_sim_mat[t, unemployed & (finds_job)] = iw_til[unemployed & (finds_job)]

    mslot_sim_mat[t, unemployed & (~finds_job)] = 2
    ie_sim_mat[t, unemployed & (~finds_job)] = 0
    iw_sim_mat[t, unemployed & (~finds_job)] = iw[unemployed & (~finds_job)]

    # Expense shocks
    # Use pdf sim to decide whether this individual experiences expense shock and update b_old accordingly
    expense_shock = (ies_draw[t, :] <= px)
    expense_shock_sim_mat[t, expense_shock] = 1
    ib[expense_shock] = np.maximum(0, ib[expense_shock] - b_step).astype(int)

    # if currently has credit, assume still possess credit
    had_credit = (ic.astype(int) == 1)
    A_psi_sim_mat[t, had_credit] = 0
    c_pol_sim_mat[t, had_credit] = 999
    ic_sim_mat[t, had_credit] = 1

    # If does not have credit, given y, incomet, bold, and employment status,
    #  find whether one applies for credit c pol t. If so, use A psi t to
    # decide whether this individual gets credits if it applies
    idx_emp = (~had_credit) & (ie_sim_mat[t, :].astype(int) == 1)
    idx_unemp = (~had_credit) & (ie_sim_mat[t, :].astype(int) == 0)

    A_psi_sim_mat[t, idx_emp] = A_psi_w_all_mat[iy[idx_emp], iw_sim_mat[t, idx_emp], ib[idx_emp], ia_sim_mat[t, idx_emp]]
    A_psi_sim_mat[t, idx_unemp] = A_psi_u_all_mat[iy[idx_unemp], iw_sim_mat[t, idx_unemp], ib[idx_unemp], ia_sim_mat[t, idx_unemp]]

    c_pol_sim_mat[t, idx_emp] = c_pol_w_all_mat[iy[idx_emp], iw_sim_mat[t, idx_emp], ib[idx_emp], ia_sim_mat[t, idx_emp]]
    c_pol_sim_mat[t, idx_unemp] = c_pol_u_all_mat[iy[idx_unemp], iw_sim_mat[t, idx_unemp], ib[idx_unemp], ia_sim_mat[t, idx_unemp]]

    apply_credit = (c_pol_sim_mat[t, :].astype(int) == 1)
    approved = (ic_draw[t, :] <= A_psi_sim_mat[t, :])

    ic_sim_mat[t, approved & apply_credit] = 1
    ic_sim_mat[t, (~approved) & apply_credit] = 0

    ic_sim_mat[t, (~had_credit) & (~apply_credit)] = 0
    A_psi_sim_mat[t, (~had_credit) & (~apply_credit)] = 0

    # Given y, incomet, bold, employment status, and the credit access status, find the corre-
    # sponding policy function rt and bp
    WC_idx = (ie_sim_mat[t, :].astype(int) == 1) & (ic_sim_mat[t, :].astype(int) == 1)
    WN_idx = (ie_sim_mat[t, :].astype(int) == 1) & (ic_sim_mat[t, :].astype(int) == 0)
    UC_idx = (ie_sim_mat[t, :].astype(int) == 0) & (ic_sim_mat[t, :].astype(int) == 1)
    UN_idx = (ie_sim_mat[t, :].astype(int) == 0) & (ic_sim_mat[t, :].astype(int) == 0)

    ir_sim_mat[t, WC_idx] = ir_WC_mat[iy[WC_idx], iw_sim_mat[t, WC_idx], ib[WC_idx], ia_sim_mat[t, WC_idx]].astype(int)
    ib_sim_mat[t, WC_idx] = ibp_WC_mat[iy[WC_idx], iw_sim_mat[t, WC_idx], ib[WC_idx], ia_sim_mat[t, WC_idx]].astype(int)
    ir_sim_mat[t, WN_idx] = ir_WN_mat[iy[WN_idx], iw_sim_mat[t, WN_idx], ib[WN_idx], ia_sim_mat[t, WN_idx]].astype(int)
    ib_sim_mat[t, WN_idx] = ibp_WN_mat[iy[WN_idx], iw_sim_mat[t, WN_idx], ib[WN_idx], ia_sim_mat[t, WN_idx]].astype(int)
    ir_sim_mat[t, UC_idx] = ir_UC_mat[iy[UC_idx], iw_sim_mat[t, UC_idx], ib[UC_idx], ia_sim_mat[t, UC_idx]].astype(int)
    ib_sim_mat[t, UC_idx] = ibp_UC_mat[iy[UC_idx], iw_sim_mat[t, UC_idx], ib[UC_idx], ia_sim_mat[t, UC_idx]].astype(int)
    ir_sim_mat[t, UN_idx] = ir_UN_mat[iy[UN_idx], iw_sim_mat[t, UN_idx], ib[UN_idx], ia_sim_mat[t, UN_idx]].astype(int)
    ib_sim_mat[t, UN_idx] = ibp_UN_mat[iy[UN_idx], iw_sim_mat[t, UN_idx], ib[UN_idx], ia_sim_mat[t, UN_idx]].astype(int)

    # Given default decision r∗t and given the household currently has credit access, decide whether this household
    # is separated from its credit matching status
    # you have credit access and you did not default
    # determine whether this household would experience exogenouse credit loss
    # 1-sbar_i: the probability that one is not separated from their credit status
    cred_keep = (ir_sim_mat[t, :].astype(int) == (Nr-1)) &\
     (ic_sim_mat[t, :].astype(int) == 1) & (idc_draw[t, :] > (1-s_bar))
    cred_sep = (ir_sim_mat[t, :].astype(int) == (Nr-1)) &\
     (ic_sim_mat[t, :].astype(int) == 1) &\
      (~(idc_draw[t, :] > (1-s_bar)))
    default = (ir_sim_mat[t, :].astype(int) != (Nr-1))  & (ic_sim_mat[t, :].astype(int) == 1)
    no_cred = (ic_sim_mat[t, :].astype(int) == 0)

    sbar_sim_mat[t, cred_keep] = 2
    ic_cont_sim_mat[t, cred_keep] = 0
    sbar_sim_mat[t, cred_sep] = 1
    ic_cont_sim_mat[t, cred_sep] = 1
    sbar_sim_mat[t, default] = 3
    ic_cont_sim_mat[t, default] = 0
    sbar_sim_mat[t, no_cred] = 0
    ic_cont_sim_mat[t, no_cred] = ic_sim_mat[t, no_cred]

    # Given y, incomet, bold, employment status, and the credit access status, find the corre-
    # sponding bond price q (i.e., qw, qw_d, qu, qu_d)
    curr_employed = (ie_sim_mat[t, :].astype(int) == 1)
    curr_default = (ir_sim_mat[t, :].astype(int) == (Nr-1))

    mask1 = curr_employed & curr_default
    mask2 = curr_employed & (~curr_default)

    q_sim_mat[t, curr_employed & curr_default] = qw_all_mat[iy[curr_employed & curr_default],\
                                        iw_sim_mat[t, curr_employed & curr_default],\
                                        ib_sim_mat[t, curr_employed & curr_default],\
                                        ia_sim_mat[t, curr_employed & curr_default]]

    c_sim_mat[t, curr_employed & curr_default] = w_vec[iw_sim_mat[t, curr_employed & curr_default]] + \
            r_vec[Nr-1] * b_vec[ib[curr_employed & curr_default]] -\
            q_sim_mat[t, curr_employed & curr_default]*b_vec[ib_sim_mat[t, curr_employed & curr_default]]

    q_sim_mat[t, curr_employed & (~curr_default)] = qw_d_all_mat[iy[curr_employed & (~curr_default)],\
                                                    iw_sim_mat[t, curr_employed & (~curr_default)],\
                                                    ib_sim_mat[t, curr_employed & (~curr_default)],\
                                                    ia_sim_mat[t, curr_employed & (~curr_default)]]

    c_sim_mat[t, curr_employed & (~curr_default)] = w_vec[iw_sim_mat[t, curr_employed & (~curr_default)]] +\
                                r_vec[ir_sim_mat[t, curr_employed & (~curr_default)]] * b_vec[ib[curr_employed & (~curr_default)]] -\
                                q_sim_mat[t, curr_employed & (~curr_default)]*b_vec[ib_sim_mat[t, curr_employed & (~curr_default)]]

    q_sim_mat[t, (~curr_employed) & curr_default] = qu_all_mat[iy[(~curr_employed) & curr_default],\
                                                    iw_sim_mat[t, (~curr_employed) & curr_default],\
                                                    ib_sim_mat[t, (~curr_employed) & curr_default],\
                                                    ia_sim_mat[t, (~curr_employed) & curr_default]]

    c_sim_mat[t, (~curr_employed) & curr_default] = z_vec[iw_sim_mat[t,(~curr_employed) & curr_default]] + \
                                r_vec[Nr-1] * b_vec[ib[(~curr_employed) & curr_default]] -\
                                q_sim_mat[t,(~curr_employed) & curr_default]*b_vec[ib_sim_mat[t, (~curr_employed) & curr_default]]

    q_sim_mat[t, (~curr_employed) & (~curr_default)] = qu_d_all_mat[iy[ (~curr_employed) & (~curr_default)],\
                                                       iw_sim_mat[t, (~curr_employed) & (~curr_default)],\
                                                       ib_sim_mat[t, (~curr_employed) & (~curr_default)],\
                                                       ia_sim_mat[t, (~curr_employed) & (~curr_default)]]

    c_sim_mat[t, (~curr_employed) & (~curr_default)] = z_vec[iw_sim_mat[t, (~curr_employed) & (~curr_default)]] +\
                                r_vec[ir_sim_mat[t, (~curr_employed) & (~curr_default)]] * \
                                b_vec[ib[(~curr_employed) & (~curr_default)]] -\
                                q_sim_mat[t, (~curr_employed) & (~curr_default)]*\
                                b_vec[ib_sim_mat[t, (~curr_employed) & (~curr_default)]]

  ie_old_sim_mat[t, :] = ie.astype(int)
  iw_old_sim_mat[t, :] = iw.astype(int)
  ib_old_sim_mat[t, :] = ib.astype(int)
  ic_old_sim_mat[t, :] = ic.astype(int)

  ie_sim_mat = ie_sim_mat[100:, :]
  iw_sim_mat = iw_sim_mat[100:, :]
  ia_sim_mat = ia_sim_mat[100:, :]
  ib_sim_mat = ib_sim_mat[100:, :]
  ic_sim_mat = ic_sim_mat[100:, :]
  ic_cont_sim_mat = ic_cont_sim_mat[100:, :]
  ir_sim_mat = ir_sim_mat[100:, :]
  q_sim_mat = q_sim_mat[100:, :]
  c_sim_mat = c_sim_mat[100:, :]
  fireslot_sim_mat = fireslot_sim_mat[100:, :]
  mslot_sim_mat = mslot_sim_mat[100:, :]
  sbar_sim_mat = sbar_sim_mat[100:, :]
  expense_shock_sim_mat = expense_shock_sim_mat[100:, :]
  c_pol_sim_mat = c_pol_sim_mat[100:, :]
  A_psi_sim_mat = A_psi_sim_mat[100:, :]
  ie_old_sim_mat = ie_old_sim_mat[100:, :]
  iw_old_sim_mat = iw_old_sim_mat[100:, :]
  ib_old_sim_mat = ib_old_sim_mat[100:, :]
  ic_old_sim_mat = ic_old_sim_mat[100:, :]
  iagg_state  = iagg_state[100:]

  return  ie_sim_mat, iw_sim_mat, ia_sim_mat, ib_sim_mat, ic_sim_mat, ic_cont_sim_mat, ir_sim_mat,\
              q_sim_mat, c_sim_mat, fireslot_sim_mat, mslot_sim_mat, sbar_sim_mat,\
              expense_shock_sim_mat, c_pol_sim_mat, A_psi_sim_mat, ie_old_sim_mat, iw_old_sim_mat,\
              ib_old_sim_mat, ic_old_sim_mat, iagg_state